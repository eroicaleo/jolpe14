M = load('hotspot_input/matrix_b.txt');
% A = load('debug_out.txt');
% P = M * A;
% 
% G = inv(M);
% A_new = G * P;
% delta_A = abs(A - A_new);
% A = load('constant.txt');

%%----------------------------------------------------------------------------------------------------
%% Specify the peak temperature here
%%----------------------------------------------------------------------------------------------------
T_target = 273.15+90;

%%----------------------------------------------------------------------------------------------------
%% Load the task mapping file generated by cpp simulator.
%% The only thing matters here is the power on each core.
%% Temperature value does not matter.
%%----------------------------------------------------------------------------------------------------
A = load('data/debug_out_uniform.txt');
% A = load('debug_out_cool.txt');
% A = load('debug_out_hot.txt');
% A = load('debug_out_norm.txt');
% A = load('debug_out_invnorm.txt');

% A = load('corner\corner_3hop_uniform.txt');
% A = load('corner\corner_3hop_cooltriangle.txt');
% A = load('corner\corner_3hop_hottriangle.txt');
% A = load('corner\corner_3hop_norm.txt');
% A = load('corner\corner_3hop_invnorm.txt');

% A = load('corner_init_uniform.txt');
% A = load('corner_init_cooltriangle.txt');
% A = load('corner_init_hottriangle.txt');
% A = load('corner_init_norm.txt');
% A = load('corner_init_invnorm.txt');

P = A(:, 1);
T = A(:, 2);
% G_part = G([1:36], [1:36]);
% G_part_inverse = inv(G_part);
% M_part = G_part_inverse;
% 
% G_column_sum = sum(G_part)/2;
% 
% 
% a = 0.02861;
% B = (eye(36) - a * G_part);
% B_inv = inv(B);
% 
% row = sum(G_part_inverse);
% 
% D = T - G_part * P;
% D = D(:, 1);
% S = P + M_part * D;

t_max = max(T);

% Compute new matrix here
rconvection_ref = 0.05;
[G_part D] = ldt_matrix(M, rconvection_ref);

[T_LSAP1 t_max_lsap1 p_lsap1] = lsap1_optimum(G_part, P, D);
[T_optimum t_max_optimum p_optimum] = lp_optimum(G_part, P, D);
[T_LSAP2 t_max_lsap2 p_lsap2] = lsap2_optimum(G_part, P, D, p_optimum);

result = [t_max_optimum t_max_lsap1 t_max_lsap2 t_max] - 273.15;

save('matm_power.txt', 'P', '-ascii');

% Provide a group of permutation and we need to find the 
% best from the random permutation

% Initialize the random seed so we get the same results every time
rng(20141228)
Random_Permutation = [];
for i = 1:100
    Random_Permutation(:, i) = randperm(36);
end

% Now compute the system power based on new task allocation
[T_Total P_Dyn_Total] = leakage(rconvection_ref, 'hotspot_input/DBAmapping.txt', Random_Permutation);

ix = 1;
for ix = 1:5
    r_min = 0.005;
    r_max = 0.05;
    r_cur = (r_max+r_min)/2;
    while r_min <= r_max
        [T_Total P_Chip_Total] = leakage(r_cur, 'hotspot_input/DBAmapping.txt', []);
        if (T_Total(ix, 1) < T_target)
            r_min = r_cur;
        elseif (T_Total(ix, 1) > T_target)
            r_max = r_cur;
        end
        if (abs(T_Total(ix, 1)-T_target) < 0.0001)
            break;
        end
        r_cur = (r_max+r_min)/2;
    end
    r_final(ix) = r_cur;
    p_chip(ix) = P_Chip_Total(ix);
end

Fan_a = 0.001;
Fan_power = Fan_a ./ (r_final.^3);

P_total = p_chip + Fan_power;

P_Dyn = repmat(sum(P), 1, 5);
P_Leak = p_chip - P_Dyn;
Power_Breakdown = [P_Dyn; P_Leak; Fan_power];
